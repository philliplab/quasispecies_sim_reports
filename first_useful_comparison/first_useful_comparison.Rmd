---
title: First useful simulation.
output: 
  bookdown::gitbook:
    config:
      toc:
        collapse: subsection
      sharing:
        facebook: no
        twitter: no
      fontsettings:
        theme: sepia
---

```{r, include=FALSE}
library(yasss)
library(knitr)
library(rmarkdown)
library(ggthemr)

knitr::opts_chunk$set(echo = FALSE,
                      base.dir = "/home/phillipl/projects/quasispecies_sim_reports/builds/first_useful_comparison/simpleCache/figures")
options(scipen = 99)
setCacheDir("/home/phillipl/projects/quasispecies_sim_reports/builds/first_useful_comparison/simpleCache")
set.seed(1)
```

```{r , include = FALSE}
source('../utilities/reporting_utilities.R')
```

# Simulation Description

Comparing populations with a fitness contraint to populations with no fitness constraint.

Simulate 10 datasets with 1024 individuals and uniformly assigned fitness scores.

Assign the first 1+2+4+8=15 sequences a fitness of 1 - to prevent massive parts of the dataset from getting excluded.

Then, do a fitness based selection with a score of 0.05.

Assign that as sim_id n to group 1.

Next select that same number of individuals from the last generation completely ignoring the fitness score and assign that as sim_id n+1 to group 2.

Repeat until 10 simulations in each dataset.

```{r, include=FALSE}

args1 <- list(
  ancestors = paste(rep("A", 500), collapse = ''),
  r0 = 2,
  n_gen = 10,
  n_pop = Inf,
  mutator = list(fun = "mutator_uniform_fun",
                 args = list(mu = 1/500)),
  fitness_evaluator = list(fun = "fitness_evaluator_uniform_fun",
                           args = NULL)
)

arg_sets <- list(`1` = list(group_label = "restricted",
                            group_desc = "with r0 = 2, 10 generations and mu equal to 1/500 and required fitness of 0.05",
                            args = args1),
                 `2` = list(group_label = "unrestricted",
                            group_desc = "with r0 = 2, 10 generations and mu equal to 1/500 and a random sample to match the size of the fitness restricted version",
                            args = args1))

group_membership <- NULL
all_sim_results <- NULL
i <- 0
md5s <- NULL
for (i in 1:10){
#  x <- do.call(sim_pop, args1)
  suppressMessages({
  x <- memoiseCache(fun = 'sim_pop', args = args1, cacheName = 'first_useful', seed = i)
  })
  x$fitness_score[1:15] <- 1
  y <- get_fit_offspring(x, 0.1)
  original_col <- names(y)
  y$sim_id <- i*2-1
  y$group_label <- 'restricted'
  y <- y %>% select(sim_id, group_label, original_col)

  y_last_gen_size <- nrow(y %>% filter(gen_num == max(gen_num)))
  x_last_gen_size <- nrow(x %>% filter(gen_num == max(gen_num)))
  x1 <- (x %>% filter(gen_num == max(gen_num)))[sample(1:x_last_gen_size, y_last_gen_size),]
  x2 <- rbind((x %>% filter(gen_num != max(gen_num))), x1)
  x2_last_gen_size <- nrow(x2 %>% filter(gen_num == max(gen_num)))
  stopifnot(x2_last_gen_size == y_last_gen_size)

  x2$sim_id <- i*2
  x2$group_label <- "unrestricted"
  x2 <- x2 %>% select(sim_id, group_label, original_col)

  if (is.null(all_sim_results)){
    all_sim_results <- rbind(y, x2)
  } else {
    all_sim_results <- rbind(all_sim_results,
                             rbind(y, x2))
  }

  if (is.null(group_membership)){
    group_membership <- data.frame(sim_id = 1:2, group_id = 1:2)
  } else {
    group_membership <- rbind(group_membership,
      data.frame(sim_id = c(i*2-1, i*2), 
                 group_id = 1:2)
      )
  }

}
print(md5s)
```

# Simulation Results
The following graphs and tables present a summary of a set of simulations that can be divided into `r length(unique(group_membership$group_id))` groups. 

```{r, include = FALSE}
seq_length <- nchar(all_sim_results[1,'the_seq'])

last_gens <-
all_sim_results %>%
  filter(gen_num == max(gen_num))

dd.f <- NULL
for (c_sim_id in unique(all_sim_results$sim_id)){
  c_group_label <- unique(last_gens$group_label[last_gens$sim_id == c_sim_id])
  stopifnot(length(c_group_label) == 1)
  dmat <- stringdistmatrix(last_gens$the_seq[last_gens$sim_id == c_sim_id], method = 'hamming')
  avg_hd <- mean(dmat)
  dvec <- as.numeric(dmat)/min(nchar(last_gens$the_seq))
  dd.f <- rbind(dd.f,
    data.frame(sim_id = c_sim_id,
               group_label = c_group_label,
               dists = dvec)
  )
}
```
```{r, results = 'asis'}

kable(
  dd.f %>%
    group_by(group_label) %>%
    summarize(avg_hd = round(mean(dists),4),
              n_avg_hd = round(mean(dists)/seq_length, 7)),
  booktabs = TRUE,
  caption = "The average pairwise HD in each group of simulations"
)
```

```{r, fig.cap='Density plot of the pariwise distances in the last generation', results = 'asis'}
n_uniq <- length(unique(dd.f$dists))
range_length <- max(dd.f$dists) - min(dd.f$dists)
bw <- range_length / min((n_uniq*1.75), 200)
ggplot(dd.f, aes(x = dists, 
                 col = group_label,
                 group = as.factor(sim_id))) + 
      geom_density(bw = bw)
```

```{r, results = 'asis'}
all_deciles <- data.frame(matrix(0, ncol = 12, nrow = length(unique(all_sim_results$group_label))))
names(all_deciles) <- c('Sim', paste((0:10)*10, "%", sep = ''))

i <- 0
for (c_group_label in unique(all_sim_results$group_label)){
  i <- i + 1
  deciles <-
    quantile(dd.f$dists[dd.f$group_label == c_group_label], (0:10)/10)

  all_deciles[i,] <- c(c_group_label, deciles)
}
row.names(all_deciles) <- NULL

kable(
  all_deciles,
  booktabs = TRUE,
  caption = "The deciles of the pairwise HDs"
)
```

```{r, results = 'asis'}
arg_tab <- NULL
for (c_group_id in names(arg_sets)){
  c_arg_tab <- sim_pop_arg_formatter(arg_sets[[c_group_id]]$args)
  original_cols <- names(c_arg_tab)
  c_arg_tab$group_label <- arg_sets[[c_group_id]]$group_label
  c_arg_tab <- c_arg_tab %>% select(group_label, original_cols)
  if (is.null(arg_tab)){
    arg_tab <- c_arg_tab
  } else {
    arg_tab <- rbind(arg_tab, c_arg_tab)
  }
}

kable(
  arg_tab,
  booktabs = TRUE,
  caption = "Configuration with which sim_pop was called for the group for each group of simulations."
)
```

```{r, results = 'asis'}
all_sum_tabs <- NULL
for (c_group_label in unique(all_sim_results$group_label)){
  g_sum_tab <- genealogy_summary_table(all_sim_results[all_sim_results$group_label == c_group_label, c(-1,-2)])
  original_cols <- names(g_sum_tab)
  g_sum_tab$group_label <- c_group_label
  g_sum_tab <- g_sum_tab %>% select(group_label, original_cols)
  if (is.null(all_sum_tabs)){
    all_sum_tabs <- g_sum_tab
  } else {
    all_sum_tabs <- rbind(all_sum_tabs, g_sum_tab)
  }
}

kable(
  all_sum_tabs,
  booktabs = TRUE,
  caption = "Individuals per generation and the average distance to the original ancestor for the generation for all simulations grouped by simulation group."
)
```


```{r test-child, child = '../utilities/comp_sim_chunk.Rmd'}
```
