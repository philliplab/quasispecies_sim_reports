---
title: Basic concepts of quasispecies simulation
output: 
  bookdown::gitbook:
    config:
      toc:
        collapse: subsection
      sharing:
        facebook: no
        twitter: no
      fontsettings:
        theme: sepia
---

```{r, include=FALSE}
library(yasss)
library(knitr)
library(rmarkdown)
library(ggthemr)

knitr::opts_chunk$set(echo = FALSE)
options(scipen = 99)
```

```{r , include = FALSE}
source('../utilities/reporting_utilities.R')
```

# Simple first simulation

A first simulation to demonstrate the process and the measuring tools. Table \@ref(tab:sim-pop-config) shows the configuration that was used to call `sim_pop` from the `yasss` package. A high level summary of the entire genealogy is provided in Table \@ref(tab:first-sum-tab).

```{r sim-pop-config, results = 'asis'}
args <- list(
  ancestors = paste(rep("A", 500), collapse = ''),
  r0 = 2,
  n_gen = 9,
  n_pop = Inf,
  mutator = list(fun = "mutator_uniform_fun",
                 args = list(mu = 0.1)),
  fitness_evaluator = list(fun = "fitness_evaluator_uniform_fun",
                           args = NULL)
)

x <- do.call(sim_pop, args)

kable(
  sim_pop_arg_formatter(args),
  booktabs = TRUE,
  caption = "Configuration with which sim_pop was called."
)
```

```{r first-sum-tab, results = 'asis'}
g_sum_tab <- genealogy_summary_table(x)

kable(
  g_sum_tab,
  booktabs = TRUE,
  caption = "Individuals per generation and the average distance to the original ancestor for the generation."
)
```

Our primary interested is restricted to the final generation which corresponds to the generation that we will obtain from sequencing a sample.
Hence we need to capture some of the key information about the last generation and figure out ways to compare it to other simulations.
Three key ways to look at this data is:

- The average of all the pairwise distances between the sequences.
- A density plot of the distribution of all the pairwise distances.
- The deciles / quartiles / some other set of percentiles of the distribution.

For now we will present all three. Once we have some solid results to argue about we can look at dropping some of these metrics.

```{r, include = FALSE}
last_gen <-
x %>%
  filter(gen_num == max(gen_num))

dmat <- stringdistmatrix(last_gen$the_seq, method = 'hamming')
avg_hd <- mean(dmat)
dvec <- as.numeric(dmat)/min(nchar(last_gen$the_seq))
dd.f <- data.frame(dists = dvec)
```

The average pairwise HD is **`r round(avg_hd, 2)`** and normalized by the length of the sequence it is **`r round(avg_hd/min(nchar(last_gen$the_seq)), 3)`**. The distribution is shown in Figure \@ref(fig:first-density-plot) and the deciles are listed in Table \@ref(tab:first-deciles).

```{r first-density-plot, fig.cap='Density plot of the pariwise distances in the last generation', results = 'asis'}
n_uniq <- nrow(unique(dd.f))
range_length <- max(dd.f$dists) - min(dd.f$dists)
bw <- range_length / min((n_uniq*1.75), 200)
ggplot(dd.f, aes(x = dists)) + geom_density(bw = bw)
```

```{r first-deciles, results = 'asis'}
deciles <-
data.frame(Decile = paste((0:10)*10, "%", sep = ''),
           Value = quantile(dvec, (0:10)/10))
row.names(deciles) <- NULL
kable(
  deciles,
  booktabs = TRUE,
  caption = "The deciles of the pairwise HDs"
)
```

# More realistic mu

Note that the extremely high value of mu (0.1) produces sequences that rapidly diverge radically from the ancestor. To make the simulation a little more realistic, drop the mutation rate down to 1 in 1000 and try again.

```{r sim-mu-1-1000, results = 'asis'}
args <- list(
  ancestors = paste(rep("A", 500), collapse = ''),
  r0 = 2,
  n_gen = 9,
  n_pop = Inf,
  mutator = list(fun = "mutator_uniform_fun",
                 args = list(mu = 1/1e3)),
  fitness_evaluator = list(fun = "fitness_evaluator_uniform_fun",
                           args = NULL)
)

x <- do.call(sim_pop, args)

sim_result <- list(args = args,
                   genealogy = x)
```

```{r test-child, child = '../utilities/single_sim_chunk.Rmd'}
```

# Small number of simulations

The goal is to compare different simulations to each other. First, we will start with a small number of simulations that we can still pay attention to each individual simulation. Note that here we only consider simulations performed with similar parameters since comparisons based on small number of examples for stochastic processes can be very misleading. The idea is just to expand the chunk that showcases a single simulation by adding in extra density curves and extra rows into the tables.

```{r, include = FALSE}
args <- list(
  ancestors = paste(rep("A", 500), collapse = ''),
  r0 = 2,
  n_gen = 9,
  n_pop = Inf,
  mutator = list(fun = "mutator_uniform_fun",
                 args = list(mu = 1/500)),
  fitness_evaluator = list(fun = "fitness_evaluator_uniform_fun",
                           args = NULL)
)

all_sim_results <- NULL

i <- 1
for (i in 1:10){
  x <- do.call(sim_pop, args)
  original_cols <- names(x)
  x$sim_id <- i
  x <- x %>% select(sim_id, original_cols)
  all_sim_results <- rbind(all_sim_results, x)
}
```

```{r test-child, child = '../utilities/few_sim_chunk.Rmd'}
```

# Sets of different simulations

The true goal is to compare sets of simulations where some parameter was varied to each other. Initially due to computational restraints (upgrades needed to yasss as well as some caching facilities), we will restrict this to comparisons of small numbers of simulations (~30) grouped into 2 to 4 groups. The goal here is to show how the distributions and the metrics diverge between the groups.

Four data structures are used to track all this:

- the all_sim_results data.frame - see the few_sim_chunk
- the group_membership data.frame: sim_id, group_id, group_label and group description
- arg_sets: A list indexed by group_id. Each element is a list with three elements:
    - group_label: The label used to describe the group
    - group_desc: The full description of the group
    - args: The list of arguments used with do.call to run sim_pop

```{r, include=FALSE}
group_membership <- data.frame(
  sim_id = 1:20,
  group_id = sort(rep(c(1,2), times = 10))
)

args1 <- list(
  ancestors = paste(rep("A", 500), collapse = ''),
  r0 = 2,
  n_gen = 9,
  n_pop = Inf,
  mutator = list(fun = "mutator_uniform_fun",
                 args = list(mu = 1/500)),
  fitness_evaluator = list(fun = "fitness_evaluator_uniform_fun",
                           args = NULL)
)

args2 <- list(
  ancestors = paste(rep("A", 500), collapse = ''),
  r0 = 2,
  n_gen = 9,
  n_pop = Inf,
  mutator = list(fun = "mutator_uniform_fun",
                 args = list(mu = 1/750)),
  fitness_evaluator = list(fun = "fitness_evaluator_uniform_fun",
                           args = NULL)
)

arg_sets <- list(`1` = list(group_label = "mu_002",
                            group_desc = "with r0 = 2, 9 generations and mu equal to 1/500",
                            args = args1),
                 `2` = list(group_label = "mu_0013",
                            group_desc = "with r0 = 2, 9 generations and mu equal to 1/750",
                            args = args2))

sim_id <- unique(group_membership$sim_id)[1]

all_sim_results <- NULL
for (c_sim_id in unique(group_membership$sim_id)){
  c_group_id <- group_membership[group_membership$sim_id == c_sim_id, 'group_id']
  c_group_label <- arg_sets[[which(names(arg_sets) == c_group_id)]]$group_label
  c_args <- arg_sets[[which(names(arg_sets) == c_group_id)]]$args
  
  x <- do.call(sim_pop, c_args)
  original_cols <- names(x)
  x$sim_id <- c_sim_id
  x$group_label <- c_group_label
  x <- x %>% select(sim_id, group_label, original_cols)
  all_sim_results <- rbind(all_sim_results, x)
}
```

```{r test-child, child = '../utilities/comp_sim_chunk.Rmd'}
```
