---
title: Basic homology based fitness
output: 
  html_document:
    toc: false
    theme: cerulean
---

```{r, include=FALSE}
library(yasss)
library(knitr)
library(rmarkdown)
library(tidyr)

knitr::opts_chunk$set(echo = FALSE,
                      base.dir = "/home/phillipl/projects/quasispecies_sim_reports/builds/basic_homolo_based_fitness/figures")
options(scipen = 99)
setCacheDir("/home/phillipl/projects/quasispecies_sim_reports/builds/basic_homolo_based_fitness/simpleCache")
source('../utilities/reporting_utilities.R')
report_seed <- 3000
set.seed(report_seed)

report_start_time <- proc.time()
```

```{r debugging-chunk, eval = FALSE}
getwd()
yasss:::restart_r()
setwd('/home/phillipl/projects/quasispecies_sim_reports/repo/quasispecies_sim_reports/basic_homolo_based_fitness')
library(profvis)
```

# Description

## Data generation

A first basic report exploring the effects of assigning fitness based on homology.

The ancestral sequence is specified as a sequence of only As.

A (very unrealistic) epitope is then specified as a sequence in which every 5th character is an A.

The fitness is based on the number of matches between the epitope and the sequence. A fitness of zero is assigned if the sequence perfectly matches the epitope and a fitness of one is assigned if there is no match at any point. For sequences that does neither perfectly match the epitope nor perfectly mismatch the epitope, fitness is assigned linearly beased on the number of matches.

Using this epitope, 10 pairs of datasets were generated.

First the entire quasispecies was simulated without taking fitness into account. Then, a copy is made of this genealogy and all individuals across all generations (excluding the first x generations) that has a fitness score lower than a cutoff were identified. These unfit individuals and ALL their decendents were then removed from the genealogy. The remaining individuals in the last generation of this dataset were then selected as a dataset.

To construct the partner of the dataset described above, a number of individuals are randomly selected from the last generation independent of any fitness considerations so that the same number of sequences are in each dataset.

This process was repeated to generate another 10 pairs, but with an epitope based on Cs. In this case instead of letting every 5th letter be an A, we used a C instead.

## A-based epitope

Since the ancestor perfectly matches the epitope, this produced a very high level of pressure which can be seen from the small size of the datasets.

The fitness requirement was set to 0.02. Given that the sequences are of length 500 and every 5th letter was part of the epitope, the epitope contains 100 positions. From the linear nature of the way fitness is computed, the fitness requirement of 0.02 translates to 2 positions. So if the sequence has non-As at more than 2 of the 100 epitope positions, then the sequence will be seen as fit.

## C-based epitope

This resulted in no pressure. This is a parameter choice failure. As for the A based epitope, if only three positions contains non-Cs, then the sequence is seen as fit.

Thus the simulations based on the C-based epitope contains no information.

# Interpretation

This report highlights two points:

1. Immune pressure can cut out certain parts of the evolutionary landscape which translates to a reduction in the diversity metric (for the 13 generation version)
2. This fitness scheme is inadequate.

# Designs for more a more useful version of fitness

How to modify the fitness computation to be more useful in such a way that it is easy to implement with the current tools?

What if we add in a more realistic epitope: Just 20 positions with some mismatches to the ancestor.
Then, together with this we need to constrict the space of viable sequences. To do this, add another 'epitope' consisting of about 200 positions and let a match on this yield a positive fitness. Thus the fitness computation becomes: The percentage of matches to the positive epitope less the percentage of matches to the negative epitope.

Then, should fitness be interpreted probabilistically? Does a fitness of 50% give you a 50% chance of surviving? Or do we use a cutoff?

Obviously this is still simplifications. Ideally, this will be based on amino acids and the 'positivie fitness epitope' will allow different, but not all, letters at certain positions. However, this is a bit more work to implement, so hold off on this for now.

# Other questions

Here are many next steps to explore:
1) Run it for more generations
2) Run it with a larger R0 (more offspring per individual)
3) Tweak the fitness parameters / implement alternative fitness functions (maybe add a little mroe noise into the process?)
4) Pick more realisitc epitopes? But do we really care about this? We just want to see the effect of any immune pressure?
5) Play more with the templates used to generate the reports - I just picked the first one from a textbook and it defintely is not the optimal one
6) Carefully state the hypotheses we want to test (I think this should be the first next step)
7) Set up a readme file for the project that links to the report files (and store the primary results in the repo itself also) - just make the results more reachable.

```{r, include=FALSE}
chunk_seed <- 2000000
n_gen <- 13
args1 <- list(
  ancestors = paste(rep("A", 500), collapse = ''),
  r0 = 2,
  n_gen = n_gen,
  n_pop = Inf,
  mutator = list(fun = "mutator_uniform_fun",
                 args = list(mu = 1/250)),
  fitness_evaluator = list(fun = "fitness_evaluator_homology_fun",
                           args = list(comparators = paste(rep('XXXXA', 100), collapse = ''),
                                       h2fs = "h2fs_univariate_linear_fun"))
)

args2 <- list(
  ancestors = paste(rep("A", 500), collapse = ''),
  r0 = 2,
  n_gen = n_gen,
  n_pop = Inf,
  mutator = list(fun = "mutator_uniform_fun",
                 args = list(mu = 1/250)),
  fitness_evaluator = list(fun = "fitness_evaluator_homology_fun",
                           args = list(comparators = paste(rep('XXXXC', 100), collapse = ''),
                                       h2fs = "h2fs_univariate_linear_fun"))
)

arg_sets <- list(`1` = list(group_label = "restricted_A",
                            group_desc = "with r0 = 2, 10 generations and mu equal to 1/500 and required fitness of 0.03 vs A",
                            args = args1),
                 `2` = list(group_label = "unrestricted_A",
                            group_desc = "with r0 = 2, 10 generations and mu equal to 1/500 and a random sample to match the size of the fitness restricted version vs A",
                            args = args1),
                 `3` = list(group_label = "restricted_C",
                            group_desc = "with r0 = 2, 10 generations and mu equal to 1/500 and required fitness of 0.03 vs C",
                            args = args2),
                 `4` = list(group_label = "unrestricted_C",
                            group_desc = "with r0 = 2, 10 generations and mu equal to 1/500 and a random sample to match the size of the fitness restricted version vs C",
                            args = args2))

group_membership <- data.frame(sim_id = numeric(0), 
                               group_id = integer(0))

all_sim_results <- data.frame(sim_id = numeric(0), 
                              group_label = character(0), 
                              gen_num = numeric(0), 
                              id = numeric(0), 
                              parent_id = numeric(0), 
                              the_seq = character(0), 
                              n_mut = numeric(0), 
                              recomb_pos = numeric(0), 
                              recomb_replaced = character(0), 
                              recomb_partner = numeric(0), 
                              recomb_muts = numeric(0), 
                              fitness_score = numeric(0))

profvis({
sim_result <- sim_fit_unfit_pairs(args = arg_sets[[1]]$args, 
                                  n_of_pairs = 10,
                                  group1_label = arg_sets[[1]]$group_label,
                                  group2_label = arg_sets[[2]]$group_label,
                                  group1_id = 1, group2_id = 2,
                                  all_sim_results = all_sim_results,
                                  group_membership = group_membership,
                                  seed_offset = report_seed + chunk_seed,
                                  req_fitness = 0.02, 
                                  n_perfect_fit = 255,
                                  cacheName = 'basic_homolo',
                                  verbose = TRUE)
})
all_sim_results <- sim_result$all_sim_results
group_membership <- sim_result$group_membership

sim_result <- sim_fit_unfit_pairs(args = arg_sets[[3]]$args, 
                                  n_of_pairs = 10,
                                  group1_label = arg_sets[[3]]$group_label,
                                  group2_label = arg_sets[[4]]$group_label,
                                  group1_id = 3, group2_id = 4,
                                  all_sim_results = all_sim_results,
                                  group_membership = group_membership,
                                  seed_offset = report_seed + chunk_seed,
                                  req_fitness = 0.02, 
                                  n_perfect_fit = 255,
                                  cacheName = 'basic_homolo',
                                  verbose = TRUE)

all_sim_results <- sim_result$all_sim_results
group_membership <- sim_result$group_membership
```

# Simulation Results

```{r test-child, child = '../utilities/comp_sim_chunk.Rmd'}
```

# Total Running Time
```{r}
print(proc.time() - report_start_time)
```
