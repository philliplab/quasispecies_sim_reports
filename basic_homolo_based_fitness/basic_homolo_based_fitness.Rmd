---
title: Basic homology based fitness
output: 
  html_document:
    toc: false
    theme: cerulean
---

```{r, include=FALSE}
library(yasss)
library(knitr)
library(rmarkdown)
library(tidyr)

knitr::opts_chunk$set(echo = FALSE,
                      base.dir = "/home/phillipl/projects/quasispecies_sim_reports/builds/basic_homolo_based_fitness/figures")
options(scipen = 99)
setCacheDir("/home/phillipl/projects/quasispecies_sim_reports/builds/basic_homolo_based_fitness/simpleCache")
source('../utilities/reporting_utilities.R')
report_seed <- 3000
set.seed(report_seed)

report_start_time <- proc.time()
```

```{r debugging-chunk, eval = FALSE}
yasss:::restart_r()
```

# Description

A first basic report exploring the effects of assigning fitness based on homology.

The ancestral sequence is specified as a sequences of only As.

A (very unrealistic) epitope is then specified as a sequence in which every 5th character is an A.

The fitness is based on the number of matches between the epitope and the sequence. A fitness of zero is assigned if the sequence perfectly matches the epitope and a fitness of one is assigned if there is no match at any point. For sequences that does neither perfectly match the epitope nor perfectly mismatch the epitope, fitness is assigned linearly beased on the number of matches.

Using this epitope, 10 pairs of datasets were generated.

First the entire quasispecies was simulated without taking fitness into account. Then, a copy is made of this genealogy and all individuals across all generations (excluding the first x generations) that has a fitness score lower than a cutoff were identified. These unfit individuals and ALL their decendents were then removed from the genealogy. The remaining individuals in the last generation of this dataset were then selected as a dataset.

To constract the partner of the dataset described above, a number of individuals are randomly selected


Start with an ancestor of only As and then run two comparisons:

- One against a comparator that is only As and Xs - 4 Xs and then an A repeated - using the
  current fitness selection tools this will not work since the ancestor will
  die. Hack around it by assigning the first couple of generations perfect
  fitness. (currently the first 63 rows)
- One against a similar comparator, but with the As replaced with Cs

basic_homolo_report

Here I made the fitness mechanism more realistic:
All simulations start with an ancestor that is just 500 As
An 'epitope' is specified and the fitness of the individual is based on the presence of this epitope.
The epitope is just that each 5th base is an A, so initially the epitope is present in all the sequences. To keep them all from getting removed summarily from the simulation, the first 6 generations are granted perfect fitness.

After the simulation is completed, two datasets are generated from each simulation:
The first dataset is constructed by removing all the unfit individuals and all the individuals that have an unfit ancestor from the dataset. The remaining members of the last generation are then taken to be the dataset.
A second dataset is made by sampling a random number of individuals from the last generation of the simulation irrespective of any fitness consideration. The number sampled is that same at the number of individuals in the first dataset.

This same process was repeated, but using an epitope in which each 5th letter is a C, thus the original ancestor does not match this epitope at all.

The datasets based on the every 5th is an A epitope show large differences. The average pairwise HD in the restricted datasets was 43 (out of 500) and 48 on the unrestricted datasets.

No difference was observed for the C-based epitopes. But this is a side effect of the way the fitness cutoffs were chosen.

The same pattern was observed for the deciles.

In the final table in the report you can see that no sequecnes were removed in any of the simulations for the c-based epitopes - so poor parameter choices on my part.

Here are many next steps to explore:
1) Run it for more generations
2) Run it with a larger R0 (more offspring per individual)
3) Tweak the fitness parameters / implement alternative fitness functions (maybe add a little mroe noise into the process?)
4) Pick more realisitc epitopes? But do we really care about this? We just want to see the effect of any immune pressure?
5) Play more with the templates used to generate the reports - I just picked the first one from a textbook and it defintely is not the optimal one
6) Carefully state the hypotheses we want to test (I think this should be the first next step)
7) Set up a readme file for the project that links to the report files (and store the primary results in the repo itself also) - just make the results more reachable.


```{r, include=FALSE}
chunk_seed <- 2000000
n_gen <- 14
args1 <- list(
  ancestors = paste(rep("A", 500), collapse = ''),
  r0 = 2,
  n_gen = n_gen,
  n_pop = Inf,
  mutator = list(fun = "mutator_uniform_fun",
                 args = list(mu = 1/250)),
  fitness_evaluator = list(fun = "fitness_evaluator_homology_fun",
                           args = list(comparators = paste(rep('XXXXA', 100), collapse = ''),
                                       h2fs = "h2fs_univariate_linear_fun"))
)

args2 <- list(
  ancestors = paste(rep("A", 500), collapse = ''),
  r0 = 2,
  n_gen = n_gen,
  n_pop = Inf,
  mutator = list(fun = "mutator_uniform_fun",
                 args = list(mu = 1/250)),
  fitness_evaluator = list(fun = "fitness_evaluator_homology_fun",
                           args = list(comparators = paste(rep('XXXXC', 100), collapse = ''),
                                       h2fs = "h2fs_univariate_linear_fun"))
)

arg_sets <- list(`1` = list(group_label = "restricted_A",
                            group_desc = "with r0 = 2, 10 generations and mu equal to 1/500 and required fitness of 0.03 vs A",
                            args = args1),
                 `2` = list(group_label = "unrestricted_A",
                            group_desc = "with r0 = 2, 10 generations and mu equal to 1/500 and a random sample to match the size of the fitness restricted version vs A",
                            args = args1),
                 `3` = list(group_label = "restricted_C",
                            group_desc = "with r0 = 2, 10 generations and mu equal to 1/500 and required fitness of 0.03 vs C",
                            args = args2),
                 `4` = list(group_label = "unrestricted_C",
                            group_desc = "with r0 = 2, 10 generations and mu equal to 1/500 and a random sample to match the size of the fitness restricted version vs C",
                            args = args2))

group_membership <- data.frame(sim_id = numeric(0), 
                               group_id = integer(0))

all_sim_results <- data.frame(sim_id = numeric(0), 
                              group_label = character(0), 
                              gen_num = numeric(0), 
                              id = numeric(0), 
                              parent_id = numeric(0), 
                              the_seq = character(0), 
                              n_mut = numeric(0), 
                              recomb_pos = numeric(0), 
                              recomb_replaced = character(0), 
                              recomb_partner = numeric(0), 
                              recomb_muts = numeric(0), 
                              fitness_score = numeric(0))

#sim_fit_unfit_pairs <- function(args, n_of_pairs,
#                                group1_label, group2_label, 
#                                group1_id, group2_id, 
#                                all_sim_results, group_membership,
#                                seed_offset,
#                                req_fitness = 0.02, n_perfect_fit = 15, 
#                                cacheName = NULL, verbose = FALSE){
#  ptm <- proc.time()
#  ltm <- proc.time()
#  if (nrow(all_sim_results) == 0){
#    index_offset <- 0
#  } else {
#    index_offset <- max(all_sim_results$sim_id)
#  }
#  for (i in 1:n_of_pairs){
#    if (verbose){
#      print('===============================')
#      print(paste(i * 2 + index_offset - 1,
#                  " and ",
#                  i * 2 + index_offset,
#                  sep = ''))
#      print(proc.time() - ptm)
#      print(proc.time() - ltm)
#      ltm <- proc.time()
#    }
#    suppressMessages({
#      x <- memoiseCache(fun = 'sim_pop', args = args, cacheName = cacheName, 
#                        seed = seed_offset + i + index_offset/2)
#    })
#    x$fitness_score[1:n_perfect_fit] <- 1
#    y <- get_fit_offspring(x, req_fitness)
#    
#    original_col <- names(y)
#    y$sim_id <- (i*2+index_offset)-1
#
#    y$group_label <- group1_label
#    y <- y %>% select(sim_id, group_label, original_col)
#
#    y_last_gen_size <- nrow(y %>% filter(gen_num == max(gen_num)))
#    x_last_gen_size <- nrow(x %>% filter(gen_num == max(gen_num)))
#    x1 <- (x %>% filter(gen_num == max(gen_num)))[sample(1:x_last_gen_size, y_last_gen_size),]
#    x2 <- rbind((x %>% filter(gen_num != max(gen_num))), x1)
#    x2_last_gen_size <- nrow(x2 %>% filter(gen_num == max(gen_num)))
#    stopifnot(x2_last_gen_size == y_last_gen_size)
#  
#    x2$sim_id <- (i * 2 + index_offset)
#    x2$group_label <- group2_label
#    x2 <- x2 %>% select(sim_id, group_label, original_col)
#
#    all_sim_results <- rbind(all_sim_results,
#                             rbind(y, x2))
#    
#    group_membership <- rbind(group_membership,
#      data.frame(sim_id = c(i * 2 + index_offset-1, i*2+index_offset), 
#                 group_id = c(group1_id, group2_id))
#      )
#  }
#  return(list(all_sim_results = all_sim_results,
#              group_membership = group_membership))
#}

sim_result <- sim_fit_unfit_pairs(args = arg_sets[[1]]$args, 
                                  n_of_pairs = 10,
                                  group1_label = arg_sets[[1]]$group_label,
                                  group2_label = arg_sets[[2]]$group_label,
                                  group1_id = 1, group2_id = 2,
                                  all_sim_results = all_sim_results,
                                  group_membership = group_membership,
                                  seed_offset = report_seed + chunk_seed,
                                  req_fitness = 0.02, 
                                  n_perfect_fit = 255,
                                  cacheName = 'basic_homolo',
                                  verbose = TRUE)

all_sim_results <- sim_result$all_sim_results
group_membership <- sim_result$group_membership

sim_result <- sim_fit_unfit_pairs(args = arg_sets[[3]]$args, 
                                  n_of_pairs = 10,
                                  group1_label = arg_sets[[3]]$group_label,
                                  group2_label = arg_sets[[4]]$group_label,
                                  group1_id = 3, group2_id = 4,
                                  all_sim_results = all_sim_results,
                                  group_membership = group_membership,
                                  seed_offset = report_seed + chunk_seed,
                                  req_fitness = 0.02, 
                                  n_perfect_fit = 255,
                                  cacheName = 'basic_homolo',
                                  verbose = TRUE)

all_sim_results <- sim_result$all_sim_results
group_membership <- sim_result$group_membership
```

# Simulation Results

```{r test-child, child = '../utilities/comp_sim_chunk.Rmd'}
```

# Total Running Time
```{r}
print(proc.time() - report_start_time)
```
