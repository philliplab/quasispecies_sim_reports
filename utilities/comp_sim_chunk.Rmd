The following graphs and tables present a summary of a series of simulations based on `r length(many_pops$arg_collection)` sets of arguments.

Each set of arguments can produce 1 or 2 sets of simulations:

* Either it is just a single simulation each time the argument set is used to
  produce simulation, or
* A matched pair is produced each time where one member of the pair had fitness
  contraints placed on it and the other did not. In most cases, the simulation
  that was not fitness constrained will be randomly sampled so that it contains
  the same number of sequences in the last generation as the fitness
  constrained member of the pair.

### Argument Sets

The following tables states the full parameter sets that were used to run the
simulations.

```{r arg-set-tables, results = 'asis'}
all_dat <- NULL
for (i in 1:length(many_pops$arg_collection)){
  all_dat <- rbind(all_dat,
    data.frame(Argument = paste("Argument Set ", i, sep = ''),
               Value = '==============================',
               stringsAsFactors = FALSE))
  all_dat <- rbind(all_dat,
    sim_pop_arg_formatter(many_pops$arg_collection[[i]]))
}
for (i in 1:nrow(all_dat)){
  if (nchar(all_dat[i,2]) > 30){
    all_dat[i,2] <- paste(substr(all_dat[i,2], 1, 28), '...', sep = '')
  }
}
kable(all_dat,
  booktabs = TRUE,
  caption = "Details about the argument sets")
```

### Effects of fitness processing

```{r fitness-processing-effects, results = 'asis'}
fpm_df <- fitness_processing_metrics_to_df(many_pops$fitness_processing_metrics)
max_input_seqs <- max(fpm_df$input_seqs)


down_selection <- unique(fpm_df[,c('sim_id', 'label', 'input_seqs', 'output_seqs')])

ggplot(down_selection, aes(x = output_seqs, color = label, fill = label)) +
  geom_density(alpha = 0.75) +
  scale_x_continuous(limits = c(0, max_input_seqs)) +
  labs(fill = "Label", color = "Label", x = "Number of Output Sequences", y = "Density")
```

**Figure:** Effects of fitness processing on the number of sequences in the simulations. The largest number of sequences in any last generation was `r max_input_seqs`.

### Summary tables of average pairwise distances

Keeping track of the averages is a little tricky because there are two levels of averaging:

* The averaging of the individual pairwise distances of a single distance matrix. **(Avg. Pairw. HD)**
* The averaging of the already averaged pairwise distances when considering multiple simulations. **(Avg. Avg. Pairw. HD)** and **(SD. Avg. Pairw. HD)**

This also introduces two different levels at which standard deviations can be computed:

* The standard deviation of the pairwise distances in a single distance matrix. **(SD. Pairw. HD)**
* The standard deviation of the already averaged pairwise distances when considering multiple simulations. **(SD. Avg. Pairw. HD)** and **(SD. SD. Pairw. HD)**

```{r avg-hd-summary-table, results = 'asis'}
seq_length <- nchar(many_pops$arg_collection[[1]]$ancestor[1])

x <- dcollection_to_df(many_pops$dcollection)
dmat_metrics <- x$dmat_metrics
dmat_distribution_df = x$dmat_distribution_df

avg_hd_summary_table <- dmat_metrics %>% 
    filter(metric == 'avg_hd') %>%
    group_by(group_label) %>%
    summarize(avg_avg_hd = mean(value),
              sd_avg_hd = sd(value),
              n_avg_hd = mean(value) / seq_length,
              n_sd_avg_hd = sd(value/seq_length))

sd_hd_summary_table <- dmat_metrics %>% 
    filter(metric == 'sd_hd') %>%
    group_by(group_label) %>%
    summarize(avg_sd_hd = mean(value),
              sd_sd_hd = sd(value))

names(avg_hd_summary_table) <- c(
  "Label",
  "Avg. Avg. Pairw. HD.",
  "SD of Avg. Pairw. HD.",
  "Norm. Avg. Avg. Pairw. HD.",
  "SD of Norm. Avg. Pairw. HD.")

names(sd_hd_summary_table) <- c(
  "Label",
  "Avg. of SD of Pairw. HD.",
  "SD of SD of Pairw. HD.")

kable(avg_hd_summary_table,
  booktabs = TRUE,
  caption = "The average pairwise HD in each group of simulations"
)

kable(sd_hd_summary_table,
  booktabs = TRUE,
  caption = "The standard deviation of the pairwise HD in each group of simulations"
)
```

### Significant differences between the fit/unfit variants?

Note that this section contains a loop that runs once for each unique label.

```{r}
c_label <- "A"
for (c_label in levels(dmat_metrics$label)){
  cat('\n---\n')
  cat(paste('\nConsidering simulations with label ', c_label, '\n', sep = ''))
  c_dmat_metrics <- dmat_metrics %>% 
    filter(label == c_label)

  c_dmat_hds <- c_dmat_metrics %>%
    filter(metric == 'avg_hd')

  avg_hd_values <- list()

  for (c_sampling in as.character(unique(c_dmat_hds$sampling))){
    c_sample <- c_dmat_hds %>%
      filter(sampling == c_sampling)
    
    avg_hd_values[[c_sampling]] <- c_sample$value
  }

  cat(paste('\nSample_1 is ', names(avg_hd_values)[1], '\n', sep = ''))
  cat(paste('\nSample_2 is ', names(avg_hd_values)[2], '\n', sep = ''))

  print(t.test(avg_hd_values[[1]], avg_hd_values[[2]]))
}
```

### Density plots of pairwise distance distributions

```{r density-plots, fig.cap='Density plot of the pariwise distances in the last generation', results = 'asis'}
ggplot(dmat_distribution_df, aes(x = x, y = y, group = uniq_id, color = group_label)) +
  geom_smooth(se = FALSE, size = 0.75, span = 0.1, method = 'loess') + 
  guides(color = guide_legend(title = "Group Label")) +
  ylab("Density") +
  xlab("Pairwise Hamming Distance")
```

```{r density-plots-sep, results = 'asis'}
for (i in unique(dmat_distribution_df$label)){
  print(i)
  print(
    ggplot(subset(dmat_distribution_df, label == i), 
           aes(x = x, y = y, group = uniq_id, color = group_label)) +
      geom_smooth(se = FALSE, size = 0.75, span = 0.1, method = 'loess') + 
      guides(color = guide_legend(title = "Group Label")) +
      ylab("Density") +
      xlab("Pairwise Hamming Distance")
  )
}
```

### Tables of average deciles of the distributions

```{r deciles, results = 'asis'}
deciles <-
dmat_metrics %>% 
  filter(grepl("%$", metric)) %>%
  group_by(group_label, metric) %>%
  summarize(
    value = mean(value)
   )

ordered_perc_labels <- paste((0:10)*10, "%", sep = "")
deciles$metric <- factor(deciles$metric, ordered_perc_labels)

all_deciles <-
spread(deciles, metric, value)

kable(
  all_deciles,
  booktabs = TRUE,
  caption = "The deciles of the pairwise HDs"
)
```

```{r arguments-table, results = 'asis'}
#i <- 1
#for (i in 1:length(arg_collection)){
#  c_arg_set <- arg_collection[[i]]
#  c_arg_tab <- sim_pop_arg_formatter(c_arg_set)
#
#}
#
#for (label in levels(dmat_metrics$label)){
#  for (samp in levels(dmat_metrics$sampling)){
#
#  }
#}



#arg_tab <- NULL
#for (c_group_id in names(arg_sets)){
#  c_arg_tab <- sim_pop_arg_formatter(arg_sets[[c_group_id]]$args)
#  original_cols <- names(c_arg_tab)
#  c_arg_tab$group_label <- arg_sets[[c_group_id]]$group_label
#  c_arg_tab <- c_arg_tab %>% select(group_label, original_cols)
#  if (is.null(arg_tab)){
#    arg_tab <- c_arg_tab
#  } else {
#    arg_tab <- rbind(arg_tab, c_arg_tab)
#  }
#}
#for (i in 1:nrow(arg_tab)){
#  if (nchar(arg_tab$Value[i]) > 50){
#    arg_tab$Value[i] <- paste(substr(arg_tab$Value[i], 1, 50), '...', sep = '')
#  }
#}
#
#names(arg_tab)[1] <- "Group Label"
#
#kable(
#  arg_tab,
#  booktabs = TRUE,
#  caption = "Configuration with which sim_pop was called for the group for each group of simulations."
#)
```

```{r generation-summary-table, results = 'asis'}
#all_sum_tabs <- NULL
#for (c_group_label in unique(all_sim_results$group_label)){
#  g_sum_tab <- genealogy_summary_table(all_sim_results[all_sim_results$group_label == c_group_label, c(-1,-2)])
#  original_cols <- names(g_sum_tab)
#  g_sum_tab$group_label <- c_group_label
#  g_sum_tab <- g_sum_tab %>% select(group_label, original_cols)
#  if (is.null(all_sum_tabs)){
#    all_sum_tabs <- g_sum_tab
#  } else {
#    all_sum_tabs <- rbind(all_sum_tabs, g_sum_tab)
#  }
#}
#
#names(all_sum_tabs)[1] <- "Group Label"
#
#kable(
#  all_sum_tabs,
#  booktabs = TRUE,
#  caption = "Individuals per generation and the average distance to the original ancestor for the generation for all simulations grouped by simulation group."
#)
```

```{r dmat-calc-time-table, results = 'asis'}
#kable(dmat_calc_times,
#      booktabs = TRUE,
#      caption = "Computation time of the distance matrices"
#      )
```

