The following graphs and tables present a summary of a series of simulations based on `r length(many_pops$arg_collection)` sets of arguments.

Each set of arguments can produce 1 or 2 sets of simulations:

* Either it is just a single simulation each time the argument set is used to
  produce simulation, or
* A matched pair is produced each time where one member of the pair had fitness
  contraints placed on it and the other did not. In most cases, the simulation
  that was not fitness constrained will be randomly sampled so that it contains
  the same number of sequences in the last generation as the fitness
  constrained member of the pair.

### Argument Sets

The following tables states the full parameter sets that were used to run the
simulations.

```{r arg-set-tables, results = 'asis'}
all_dat <- NULL
for (i in 1:length(many_pops$arg_collection)){
  all_dat <- rbind(all_dat,
    data.frame(Argument = paste("Argument Set ", i, sep = ''),
               Value = '==============================',
               stringsAsFactors = FALSE))
  all_dat <- rbind(all_dat,
    sim_pop_arg_formatter(many_pops$arg_collection[[i]]))
}
for (i in 1:nrow(all_dat)){
  if (nchar(all_dat[i,2]) > 30){
    all_dat[i,2] <- paste(substr(all_dat[i,2], 1, 28), '...', sep = '')
  }
}
kable(all_dat,
  booktabs = TRUE,
  caption = "Details about the argument sets")
```

### Effects of fitness processing

```{r fitness-processing-effects, results = 'asis'}
fpm_df <- fitness_processing_metrics_to_df(many_pops$fitness_processing_metrics)
max_input_seqs <- max(fpm_df$input_seqs)


down_selection <- unique(fpm_df[,c('sim_id', 'label', 'input_seqs', 'output_seqs')])

ggplot(down_selection, aes(x = output_seqs, color = label, fill = label)) +
  geom_density(alpha = 0.75) +
  scale_x_continuous(limits = c(0, max_input_seqs)) +
  labs(fill = "Label", color = "Label", x = "Number of Output Sequences", y = "Density")
```

**Figure:** Effects of fitness processing on the number of sequences in the simulations. The largest number of sequences in any last generation was `r max_input_seqs`.

### Summary tables of average pairwise distances

```{r avg-hd-summary-table, results = 'asis'}
seq_length <- nchar(many_pops$arg_collection[[1]]$ancestor[1])

x <- dcollection_to_df(many_pops$dcollection)
dmat_metrics <- x$dmat_metrics
dmat_distribution_df = x$dmat_distribution_df

avg_hd_summary_table <- dmat_metrics %>% 
    filter(metric == 'avg_hd') %>%
    group_by(group_label) %>%
    summarize(avg_avg_hd = mean(value),
              sd_avg_hd = sd(value),
              n_avg_hd = mean(value) / seq_length,
              n_sd_avg_hd = sd(value/seq_length))

sd_hd_summary_table <- dmat_metrics %>% 
    filter(metric == 'sd_hd') %>%
    group_by(group_label) %>%
    summarize(avg_sd_hd = mean(value),
              sd_sd_hd = sd(value))

names(avg_hd_summary_table) <- c(
  "Label",
  "Avg. Avg. Pairwise HD.",
  "SD of Avg. Pairw. HD.",
  "Norm. Avg. Avg. Pairwise HD.",
  "SD of Norm. Avg. Pairw. HD.")

names(sd_hd_summary_table) <- c(
  "Label",
  "Avg. of SD of Pairw. HD.",
  "SD of SD of Pairw. HD.")

kable(avg_hd_summary_table,
  booktabs = TRUE,
  caption = "The average pairwise HD in each group of simulations"
)

kable(sd_hd_summary_table,
  booktabs = TRUE,
  caption = "The Standard Deviation of the pairwise HD in each group of simulations"
)
```

### Density plots of pairwise distance distributions

```{r density-plots, fig.cap='Density plot of the pariwise distances in the last generation', results = 'asis'}
ggplot(dmat_distribution_df, aes(x = x, y = y, group = uniq_id, color = group_label)) +
  geom_smooth(se = FALSE, size = 0.75, span = 0.1, method = 'loess') + 
  guides(color = guide_legend(title = "Group Label")) +
  ylab("Density") +
  xlab("Pairwise Hamming Distance")
```

```{r density-plots-sep, results = 'asis'}
for (i in unique(dmat_distribution_df$label)){
  print(i)
  print(
    ggplot(subset(dmat_distribution_df, label == i), 
           aes(x = x, y = y, group = uniq_id, color = group_label)) +
      geom_smooth(se = FALSE, size = 0.75, span = 0.1, method = 'loess') + 
      guides(color = guide_legend(title = "Group Label")) +
      ylab("Density") +
      xlab("Pairwise Hamming Distance")
  )
}
```

### Tables of average deciles of the distributions

```{r deciles, results = 'asis'}
deciles <-
dmat_metrics %>% 
  filter(grepl("%$", metric)) %>%
  group_by(group_label, metric) %>%
  summarize(
    value = mean(value)
   )

ordered_perc_labels <- paste((0:10)*10, "%", sep = "")
deciles$metric <- factor(deciles$metric, ordered_perc_labels)

all_deciles <-
spread(deciles, metric, value)

kable(
  all_deciles,
  booktabs = TRUE,
  caption = "The deciles of the pairwise HDs"
)
```

```{r arguments-table, results = 'asis'}
#i <- 1
#for (i in 1:length(arg_collection)){
#  c_arg_set <- arg_collection[[i]]
#  c_arg_tab <- sim_pop_arg_formatter(c_arg_set)
#
#}
#
#for (label in levels(dmat_metrics$label)){
#  for (samp in levels(dmat_metrics$sampling)){
#
#  }
#}



#arg_tab <- NULL
#for (c_group_id in names(arg_sets)){
#  c_arg_tab <- sim_pop_arg_formatter(arg_sets[[c_group_id]]$args)
#  original_cols <- names(c_arg_tab)
#  c_arg_tab$group_label <- arg_sets[[c_group_id]]$group_label
#  c_arg_tab <- c_arg_tab %>% select(group_label, original_cols)
#  if (is.null(arg_tab)){
#    arg_tab <- c_arg_tab
#  } else {
#    arg_tab <- rbind(arg_tab, c_arg_tab)
#  }
#}
#for (i in 1:nrow(arg_tab)){
#  if (nchar(arg_tab$Value[i]) > 50){
#    arg_tab$Value[i] <- paste(substr(arg_tab$Value[i], 1, 50), '...', sep = '')
#  }
#}
#
#names(arg_tab)[1] <- "Group Label"
#
#kable(
#  arg_tab,
#  booktabs = TRUE,
#  caption = "Configuration with which sim_pop was called for the group for each group of simulations."
#)
```

```{r generation-summary-table, results = 'asis'}
#all_sum_tabs <- NULL
#for (c_group_label in unique(all_sim_results$group_label)){
#  g_sum_tab <- genealogy_summary_table(all_sim_results[all_sim_results$group_label == c_group_label, c(-1,-2)])
#  original_cols <- names(g_sum_tab)
#  g_sum_tab$group_label <- c_group_label
#  g_sum_tab <- g_sum_tab %>% select(group_label, original_cols)
#  if (is.null(all_sum_tabs)){
#    all_sum_tabs <- g_sum_tab
#  } else {
#    all_sum_tabs <- rbind(all_sum_tabs, g_sum_tab)
#  }
#}
#
#names(all_sum_tabs)[1] <- "Group Label"
#
#kable(
#  all_sum_tabs,
#  booktabs = TRUE,
#  caption = "Individuals per generation and the average distance to the original ancestor for the generation for all simulations grouped by simulation group."
#)
```

```{r dmat-calc-time-table, results = 'asis'}
#kable(dmat_calc_times,
#      booktabs = TRUE,
#      caption = "Computation time of the distance matrices"
#      )
```

